## Первый запуск

Прежде, чем запустить заготовленный пример, не забудьте выполнить установку свеженькой версии RobotFremework:
```
pip install robotframework==7.2.2
```
Теперь можно приступить непосредственно к запуску (выполнять из корня проекта):
```
robot -d build --listener snapshot/CoverageListener.py ./snapshot/design0
```

## Разработка теста

В папку _test_ необходимо добавить файл с произвольным названием и расширением _.c_ (лучше давать информативные имена с постфиксом test).

Далее в код теста необходимо добавить точку входа, в каждом тесте это будет функция ```int sim_main()```, а взаимодействие с симулятором производится посредством функций ```write_mem_32``` и ```read_mem_32```, отвечающих за запись и чтение 32-битного числа по указанному адресу.

Если в тесте нужны обработчики прерываний, необходимо добавить реализации соответствующих функций:
* ```void reader_interrupt_callback(void)``` (событие завершения операции чтения на DMA);
* ```void writer_interrupt_callback(void)```(событие завершения операции записи на DMA); 
* ```void decode_interrupt_callback(void)```(событие готовности данных не декодере).
 
Важно соблюдать правильность сигнатуры, иначе при наступлении события обработчик не вызовется. 

При необходимости есть возможность сохранить декодированную картинку в файл при помощи [semihositng](#semihosting-и-с-чем-его-едят).

Код результата теста необходимо возвращать из функции ```sim_main()```, где 0 будет означать **пройденный** тест, а ненулевое значение - **проваленный**.


## Запуск теста

После написания теста осталось лишь указать, в связке с какой картинкой и каким дизайном необходимо запустить тест.

Для этого необходимо зайти в директорию *snapshot/designX*, и отредактировать *.robot* файл, содержащий конфигурацию запуска. 

В раздел ```***Test Cases***``` необходимо добавить конструкцию следующего вида:
```
Test Case Name
    [Documentation]    Тест, проверяющий фичу
    Skip
    ${RESULT} =    Run Test    example_test    exmaple_image    T   format
    ${EXPECTED} =    Set Variable    Y
```
где 
* ```Test Case Name``` - произвольное название тестового сценария
* ```[Documentation]``` [опционально] - тег, позволяющий добавить комментарий к тесту, отображаемый в итоговом отчете
* ```Skip``` [опционально] - тег, позволяющий пропустить тест при запуске
* ```example_test``` - название тестового файла без расширения *.c*, который вы писали на предыдущем шаге
* ```exmaple_image``` - название картинки из директории *img* без расширения *.jpeg/.jpg*
* ```T``` [опционально] - время таймаута в секундах. Если таймаут произошел раньше завершения теста, вернется код ошибки 124 (дефолтное значение параметра - 60)
* ```format``` [опционально] - формат изображения, которое будет использовано как референсное в памяти Qemu(дефолтное значение bmp)
* ```Y``` - ожидаемый код возврата из теста (0 - passed, 1 - soft failed, 124 - failed with timeout)

Например
```
*** Test Cases ***
Nice Dma Test
    ${RESULT} =    Run Test    dma_test    cat    5
    ${EXPECTED} =    Set Variable    124
Basic Test
    Skip
    ${RESULT} =    Run Test    decoder_test    sky
    ${EXPECTED} =    Set Variable    0
Negative Test
    [Documentation]    Супер мега тест
    Skip
    ${RESULT} =    Run Test    mega_test    logo
    ${EXPECTED} =    Set Variable    1
```

Чтобы запустить указанную конфигурацию, необходимо из корневой папки запустить скрипт:
```
# Для запуска одного дизайна (в данном случае с индексом 0)
robot -d build --listener snapshot/CoverageListener.py ./snapshot/design0
```
или
```
# Для запуска сразу всех дизайнов
robot -d build --listener snapshot/CoverageListener.py ./snapshot
```
## Результаты теста

Отчет о тестировании ```report.html``` будет помещен в папку *build*.

В отчете в разделе Documentation будет указано итоговое покрытие кода по всем запущенным тестам с учетом всех предыдущих запусков. Чтобы сбросить накопленное покрытие, необходимо сделать ```make clean```.

**ВАЖНО:** покрытие собирается только на design0 и при условии, что тест завершился не по таймауту.

## Semihosting и с чем его едят

Несмотря на то, что мы запускаем тесты в Baremetal окружении (т.е. без операционной системы, имитируя поведение программы на голом железе), существует возможность совершать некоторые системные вызовы.
Подобные системные вызовы сообщают Qemu необходимую информацию и она, в свою очередь, взаимодействует с вашей домашней ОС. Проще говоря, вы можете печатать логи в консоль и работать с файлами.

Для печати лога можете использовать просто функцию ```printf```.

Для выгрузки декодированных изображений советуем использовать файл *build/out.bmp*. Вот пример:
```
FILE* fptr = fopen("build/out.bmp", "w");
if (fptr == NULL) {
    printf("The bmp file is not opened. The program will now exit.\n");
    return 1;
}
fwrite(buffer_ptr, 1, buf_size, fptr);
fclose(fptr);
```
